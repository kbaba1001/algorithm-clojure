;; WIP
;; https://en.wikipedia.org/wiki/Tower_of_Hanoi

;; 【問題】N段のハノイの塔を解くプログラムを作成してください。ハノイの塔のルールは次のとおりです。
;; 
;; * 3本の杭と、中央に穴の開いた大きさの異なる複数の円盤があります。
;; * 最初はすべての円盤が左端の杭に小さいものが上になるように順に積み重ねられています
;; * 円盤を一回に一枚ずつどれかの杭に移動させることができるが、小さな円盤の上に大きな円盤を乗せることはできません
;; * すべての円盤を上記のルールに従って右端の杭に移動してください
;; 
;; プログラムでは杭を左からA, B, Cとし、円盤を小さい方から1,2,3,...として表現します。円盤を移動するたびに次のように杭と円盤の状態を表示してください。
;; 
;; 入力: n (任意の自然数。ひとまず3, 5, 10 の場合で動けば良しとします)
;; 出力例 (n = 3 の例):
;; A: 3 2 1
;; B:
;; C: 
;; ------
;; A: 3 2 
;; B:
;; C: 1
;; ------
;; A: 3
;; B: 2
;; C: 1
;; ------
;; A: 3
;; B: 2 1
;; C: 
;; ------
;; A: 
;; B: 2 1
;; C: 3
;; ------
;; A: 1
;; B: 2
;; C: 3
;; ------
;; A: 1
;; B: 
;; C: 3 2
;; ------
;; A: 
;; B: 
;; C: 3 2 1
;; 
;; n = 1
;; ------
;; A: 1
;; B:
;; C:
;; ------
;; A:
;; B:
;; C: 1
;; 
;; (n & (n-1)) % 3 番目の棒にある円盤を ((n| (n-1)) +1) %3 番目の棒に移動する
;; n = 2
;; ------
;; A: 2 1  (0)
;; B:      (0)
;; C:      (0)
;; ------
;; A: 2    (0)
;; B: 0    (0)
;; C: 1    (1)
;; (A -> C)
;; ------
;; A: 2    (0)
;; B: 1    (1)
;; C:      (0)
;; (A -> B)
;; ------
;; A: 1
;; B: 2
;; C: 
;; (C -> A)
;; ------
;; A: 1
;; B: 
;; C: 2
;; (B -> C)
;; ------
;; A: 
;; B: 
;; C: 2 1
;; (A -> C)

;; def hanoi(n, m = 1, arr = [(1..n).to_a.reverse, [], []])
;;   puts "A: #{arr[0]}\nB: #{arr[1]}\nC: #{arr[2]}\n------------"
;;   if arr[2].length >= n
;;     return
;;   end

;;   # ((m & (m-1)) % 3) 番目の棒にある円盤を (((m| (m-1)) +1) %3) 番目の棒に移動する
;;   tmp = arr[((m & (m - 1)) % 3)].pop
;;   if !tmp.nil?
;;     arr[(((m | (m - 1)) + 1) % 3)].push(tmp)
;;   end
;;   hanoi(n, m + 1, arr)
;; end

;; hanoi(3)

;; ((m & (m-1)) % 3) - 1 番目の棒にある円盤を (((m| (m-1)) +1) %3) - 1 番目の棒に移動する
(defn hanoi
  ([n]
   (let [a (java.util.Stack.)]
     (doseq [i (reverse (range 1 (inc n)))]
       (.push a i))
     (hanoi n 1 [a (java.util.Stack.) (java.util.Stack.)])))
  ([n m [a b c :as arr]]
   (printf "A: %s\nB: %s\nC: %s\n--------\n" a b c)
   (when (< (.size c) n)
     (let [tmp (.pop (get arr (mod (bit-and m (dec m)) 3)))]
       (when-not (nil? tmp)
         (.push (get arr (mod (inc (bit-or m (dec m))) 3)) tmp))
       (recur n (inc m) arr)))))

(hanoi 2)
